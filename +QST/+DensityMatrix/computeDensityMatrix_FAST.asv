function [rho,history] = computeDensityMatrix_FAST( X, theta, varargin )
%COMPUTEDENSITYMATRIX Summary of this function goes here
%
%   X and THETA must ...
%       - be 1D-Arrays
%       - have their NaN values at the same places.
%
% Optional Input Arguments:
%   'Iterations': Default is 100. How many iterations take place in a loop.
%   'Threshold': EXPERIMENTAL. Default is 0. Stop loop,
%       when |rho - nextrho| < threshold.

%% Validate and parse input arguments
p = inputParser;
defaultDebug = false;
addParameter(p,'Debug',defaultDebug,@islogical);
defaultHistory = false;
addParameter(p,'History',defaultHistory,@islogical);
defaultIterations = 50;
addParameter(p,'Iterations',defaultIterations,@isnumeric);
defaultMaxFockState = 100;
addParameter(p,'MaxFockState',defaultMaxFockState,@isnumeric);
defaultRho = [];
addParameter(p,'Rho',defaultRho,@ismatrix);
defaultThreshold = 0;
addParameter(p,'Threshold',defaultThreshold,@isnumeric);
parse(p,varargin{:});
c = struct2cell(p.Results);
[debug,historyOpt,N_ITERATIONS,maxFockState,nextRho,threshold] = c{:};






Xtp = X(~isnan(theta) & ~isnan(X));
theta = theta(~isnan(theta) & ~isnan(X));
X = Xtp;
clear Xtp;


%% Iteration
nX = length(X);
nextRho = gpuArray(single(QST.DensityMatrix.normalize(ones(maxFockState+1,maxFockState+1))));
A = gpuArray(single(QST.DensityMatrix.computeProjector1D( X, theta, maxFockState)));
B = A';
for iRho = 1:N_ITERATIONS
    rhoGPU = nextRho;
    Prob = sum((B*rhoGPU).*(A.'),2).'; % delivers the same result but is way faster
    Fact = single(1./(nX*Prob));
    R = (A.*Fact)*B;
    nextRho = R * rhoGPU * R/trace(rhoGPU); % ITERATION step
    nextRho = QST.DensityMatrix.normalize(nextRho); % normalization
    

end

end
